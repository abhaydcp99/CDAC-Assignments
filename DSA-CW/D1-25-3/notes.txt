Day 1: Algorithms and Data Structures
Date : 25-March-2025
-----------------------------------------

Topics: 
	- Introduction to Algorithms and Data Structures 
	- Problem solving with critical thinking
	- Data Structures
	- Types of Data Structures
	- Recursion
	
Data: Collection of raw facts.

Algorithm: Outline , the essence of computational procedure with step by step instructions.

Program:An implementation of an algorithm in some programming language.

Data Structure: Data organizationa required to solve any real life problem

Algorithm : An algorithm is a sequence of unambigious instructions/operations for solving a problem 
            for obtaining a required output for any input in a finite amount of time.

           -> always a step by step process to solve the problem.
           -> algorithm must be well defined, step by step computation procedure that takes a set of inputs
              and produces a desired output.

Characteristics : 

             -> finite   : means iska end hona jaruri hai  / it must terminate after finite number of test
             -> definite (unambigious) : each step must be precisely definite / means har step ka kuch toh meaninig hona chahiye.
             -> proper input :  it takes 0 or more inputs.
             -> output  :  it produces at  least one output / kam se kam ek toh output aana chahiye.
             -> effective :   each step must be basic and achievalble towards output. /                               
             -> language independent : algorithm can be implemented in any programming language.


Q : what is need of algorithm ?
---> 1: Scalability  -- i.e jo steps aap likh rahe ho uska scope kitna hai 
     2: Performance  -- kam time me jyada se jyada kam karna i.e performance of algorithm , i.e jiski wajah se hamara Performance improve hota hai


Algorithm stratergies :

            1: Greedy :-   It makes the locally optimal choice at each step with hope of finding a global optimum. 
                         - if i want shortest path.
                         - EX : Dijkstra' Algorithm
            
            
            2: Divide and Conquer :-  bade kam ko chote chote part me divide karlo 
                                    - Breaks the pbm in smaller subproblems and solve them recursively and combine the result
                                    - EX: Merge sort, Quick sort
            
            
            3: Dynamic programming :- It solves complex problems by breaking them down into simpler subproblem and solving each one.
                                    - har time koi naya rassta dhundhna if original has problem.
                                    - har problem ka so;ution dhundte jana hai.
                                    - EX: Knapsack problem, Fibonacci


            4: Backtracking :-  jitne bhi options hai sab ko try karna aur dhundho konsa best hai.
                               - it tries all possible solution, ignoring those that fail to satisfy the given condition or constraint until the correct one is found.
                               - sab khana try karo aur find them which is tasty.
                               - EX:String permutation, String match.
                               - Sudoku, Maze solving, N-Queen, constrint satisfication problems.

            5: Brut force :- kuch bhi kar ke solution nikal na
                           - ye memory efficient nai hota.
                           - it tries all possible solution until the correct one found.
                           - EX: String matching
                                -trying to unlock password.

            6: Recursive :- is an algorithm stratergy.
                           - solves a pbm smaller instances of the same problem.
                           - EX: Bubble , Quick, merge sort, Binary search.

            7: Searching Algorithm :- Finds an element in a data strucure.
                                     - EX: Linear, binary search.

            8: Sorting algorithm :-  Order elements in a perticular sequence.
                                     - Ex: Bubble, insertion ,delation , merge                   


Analysis of Algorithm :

              -An alalysis of algorithm is set to be efficient and fast, if it takes less time to execute and consumes less memory space.
              -kam time aur jam memmory le raha hai toh

-The performance can be mesured on the basis of :
                    1: Time complexity
                    2: Space Complexity


==================================================================================================================================================================================================================


Data Structures : A datastructures is a data organization,  management and storage format that enables efficient access and modification.
                ->  way in which a data stored on computer.
                
                -> Program = Algorithm + Data Structure


Types of Data structure :

                   1: Linear ->
                             -> Elements aare arranged in sequence, one dimension, known as Linear datastructure.
                             -> EX: Array, stack, Queue etc.

                            Array :- collection of element stored at contigious location(memory location).
                                  -EX : A supermarket shelf with a fixed number of slots, each containing the same type of product.
                                 int[] prices = {10, 20, 30, 40, 50}; // Fixed-size array
                                 System.out.println(prices[2]); // Output: 30

                                 
                                  -Dynamic Arraylist : A taxi booking app where the list of available taxis keeps changing.
                                import java.util.ArrayList;
                                 ArrayList<String> taxis = new ArrayList<>();
                                 taxis.add("Taxi 1");
                                 taxis.add("Taxi 2");
                                System.out.println(taxis); // Output: [Taxi 1, Taxi 2]


                            LinkedList :- linear collection of data elements where each element points to the next element.
                                   -EX : A train where each coach is linked to the next one and can be added or removed easily.
  
                                    import java.util.LinkedList;
                                    LinkedList<String> train = new LinkedList<>();
                                    train.add("Coach 1");
                                    train.add("Coach 2");
                                    System.out.println(train); // Output: [Coach 1, Coach 2]

                            
                            
                            Stack :- LIFO : LAST IN FIRST OUT ko follow karta hai.
                                   -EX : A stack of plates in a restaurant where the last placed plate is picked first.

                                    import java.util.Stack;
                                    Stack<String> plates = new Stack<>();
                                    plates.push("Plate 1");
                                    plates.push("Plate 2");
                                    System.out.println(plates.pop()); // Output: Plate 2

                    

                            Queue :- FIFO : FIRST IN FIRST OUT ko follow karta hai.
                                  1: Circular 
                                  2: Dequeue
                                  3: Deque : doubly ended Queue. 
                            
                                - EX: A ticket counter queue, where the first person in line gets the ticket first.

                                    import java.util.LinkedList;
                                    Queue<String> queue = new LinkedList<>();
                                    queue.add("Person 1");
                                    queue.add("Person 2");
                                    System.out.println(queue.poll()); // Output: Person 1


                        
                            HASH  :- Store key-value pair, offering fast lookup (known for its : fastest search operaton)
                   
                                >>  HashMap (Key-Value Pair)
                                  -- ðŸ“Œ Definition: Stores data as key-value pairs for quick lookup.

                                  -EX: A dictionary, where words are keys and meanings are values.

                                    import java.util.HashMap;
                                    HashMap<String, String> dictionary = new HashMap<>();
                                    dictionary.put("Java", "A programming language");
                                    dictionary.put("Python", "Another programming language");
                                    System.out.println(dictionary.get("Java")); // Output: A programming language
                                 
                                >> HashSet (Unique Elements Collection)
                                     -- ðŸ“Œ Definition: A collection that does not allow duplicate values.

                                 -EX: A guest list where no name should appear twice.

                                    import java.util.HashSet;
                                    HashSet<String> guests = new HashSet<>();
                                    guests.add("Alice");
                                    guests.add("Bob");
                                    guests.add("Alice"); // Duplicate, won't be added
                                    System.out.println(guests); // Output: [Alice, Bob]

==================================================================================================================================================                                    


Conclusion
Each data structure serves a unique purpose:

Array: Fixed-size collection

ArrayList: Dynamic-size collection

LinkedList: Efficient insertions/removals

Stack: LIFO operations (Last In, First Out)

Queue: FIFO operations (First In, First Out)

HashMap: Fast lookup with key-value pairs

HashSet: Unique elements only


===================================================================================================================================================================================================================================

                   2: Non-Linear ->
                             -> Elements are in non-sequential order (ONE - MANY, MANY - ONE, MANY - MANY DIMENSIONS) are known as non Linear datastructure.
                             -> EX: Trees, graph, heap, etc.
                            
                            Tree : Hierarchical str with root, nodes and edges.
                                 -> EX: BT, BST, AVL Trees.

                            Graph : consist of nodes (Vertices) and connected edges.

                            Heap : CBT : complete binary tree  :-
                                  -> It maintains a speciffic order od elements.
                                  -> EX : MinHeap, MaxHeap.      
===========================================================================================================================================================================

Abstract data type [ADT] :

                - ADT are datastructure used for data organization, management and storage format that anables efficient access and modification.
                - ADT is type of objects whose behaviour is defined by set of value and the set of operations.
                - SOMETHING WHICH IS ANY READYMADE FORM
                - SARI IMPLEMENTAION KO HIDE KARO 
                - MEANS MOBILE K INTERNAL PARTS HIDE HAI BAKI BAHAR SE MOBILE SIMPLE DIKHTA HAI.

===========================================================================================================================================================================

RECURSION : 
        -> Recursion is a technique where a function calls itself to solve a problem in smaller steps until it reaches a base case.
        -> Any function which calls itself directly or indirectly is known as recursion.
        -> And the corresponding function is called recursive function.
        -> a recursive method solves a problem by calling a copy of itself to work on smaller problem.
        -> its important to add termination condition in recursion.
        -> JAB BHI RECURSION PROG LIKHE TAB KBHI INFINITE LOOP NAI AANA CHAHIYE.
        
        
        < SYNTAX :-
                        
                void rescue(){
                    ....
                    ....
                    rescue();      // Recursive call
                }
                int main()
                {
                    rescue();
                }


-> ðŸ›’ Real-Life Example: Folder Structure (Recursion in Trees)
      Imagine a file explorer where a folder can contain subfolders, and each subfolder can have more subfolders.
      To display all files inside a folder structure, recursion is a natural fit.


==========================================================================================================================================================================================================================================================


                real time problem
                      |
                      |
                   algorithm 
                      |
                      |----------------->  datastructures        
                      |
input ------------> Program -----------------> output


===========================================================================================================================================================================================================================================================


                   Data structure
                        |
        ----------------|-----------------
     Primitive                      Non-Primitive
                                         |
                         --------------- | ------------------------------------
                      Linear (staic mem)                                   Non-Linear (Only Dynamic) : fix memory size
                        |                                                    |
               ---------|---------                                           |
             Static           Dynamic                                     1: Trees
               |  (fix mem)      |  (non fix)                              2: graph
               |
         1:Arrays- 1,2,3D     1: LinkedList                               operations: insertion, deletion, traversing, searching, sorting
                              2: stack
                              3: Queue


>>>>>>>>>>>  operations: insertion, deletion, traversing, searching, sorting are performed on above Arrays, LinkedList, stack, Queue, Trees and graph.
                              

 Q. difference between liner and non-linear                              

============================================================================================================================================================================================================================================================= 